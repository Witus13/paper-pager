<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../iron-selector/iron-selector.html">
<link rel="import" href="../iron-a11y-keys-behavior/iron-a11y-keys-behavior.html">

<!--
`paper-pager` is a Material Design page indicator that adapts to provided variables
and sets `selected` as user clicks on it. It doesn't require any variable but
it's higly recommended to provide `itemsCount` (as number) or `items` (as array).

Example:

    <paper-pager items-count="3" selected="{{selected}}"></paper-pager>

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-pager-color` | Color of dots | `white`
`--paper-pager-opacity` | Opacity of not selected dots | `0.7`
`--paper-pager-dots-margin` | Margin of dots | `5px`
If you quickly need to switch to dark theme you can use `dark` attribute.

@demo demo/index.html 
-->

<dom-module id="paper-pager">
  <template>
    <style>
      :host {
        margin: 5px;
        position: relative;
      }
      
      :host([dark]) {
        --paper-pager-color: black;
      }
      
      iron-selector {
        /* From https://github.com/PolymerElements/iron-flex-layout */
        display: -ms-inline-flexbox;
        display: -webkit-inline-flex;
        display: inline-flex;
      }
      
      iron-selector div {
        margin: var(--paper-pager-dots-margin, 5px);
        border-radius: 5px;
        width: 10px;
        height: 10px;
        display: inline-block;
        background-color: var(--paper-pager-color, white);
        opacity: var(--paper-pager-opacity, 0.7);
      }
      
      #canvas {
        position: absolute;
        top: 0;
        bottom: 0;
        right: 0;
        left: 0;
      }
      
      /*.dot {
        will-change: transform;
        display: none;
        position: absolute;
        border-radius: 5px;
        background-color: var(--paper-pager-color, white);
        transition: all 300ms cubic-bezier(0.4, 0.0, 0.2, 1);
      }*/
      
      /*div {
        transition: background-color 150ms cubic-bezier(0.4, 0.0, 0.2, 1);
      }*/
    </style>
    <iron-selector selected="[[selected]]">
      <template is="dom-repeat" items="[[items]]">
        <div index="[[index]]" on-tap="_onTap"></div> 
      </template>
    </iron-selector>
    <canvas id="canvas"></canvas>
  </template>
  <script>
    Polymer({
      is: 'paper-pager',
      
      behaviors: [
        Polymer.IronA11yKeysBehavior
      ],
      
      properties: {
        /**
         * Number of items. If you set this leave items empty.
         */
        itemsCount: {
          type: Number,
          value: 3,
          observer: '_computeItems'
        },
        
        /**
         * Takes an array which length will be set as itemsCount. If you set this
         * leave itemsCount empty.
         */
        items: {
          type: Array,
          observer: '_changeSize'
        },
        
        /**
         * Currently selected item's index.
         */
        selected: {
          type: Number,
          notify: true,
          reflectToAttribute: true,
          value: 0,
          observer: '_selectedChanged'
        },
        
        /**
         * Quickly switch to dark theme.
         */
        dark: {
          type: Boolean,
          value: false,
          observer: '_updateStyles'
        },
        
        /**
         * Time in ms for the animation between dots
         */
        transitionDuration: {
          type: Number,
          value: 200
        },
        
        /**
         * Time in ms for the transition to pause (when two dots connect)
         */
        pauseDuration: {
          type: Number,
          value: 150
        }
        
      },
      
      attached: function() {
        this._draw = this.$.canvas.getContext('2d');
      },
      
      _onTap: function(e) {
        this.selected = e.target.index;
      },
      
      _computeItems: function(count) {
        this.items = new Array(count);
      },
      
      _changeSize: function(items) {
        const marginPx = this.getComputedStyleValue('--paper-pager-dots-margin');
        const margin = marginPx ? marginPx.match(/\d+/)[0] : 5;
        this.$.canvas.height = (10 + 2 * margin);
        this.$.canvas.width = items.length * (10 + 2 * margin);
      },
      
      _selectedChanged: async function(selected, lastSelected) {
        if (!this._draw) return;
        const ctx = this._draw,
              color = this.getComputedStyleValue('--paper-pager-color') || 'white',
              marginPx = this.getComputedStyleValue('--paper-pager-dots-margin'),
              margin = marginPx ? marginPx.match(/\d+/)[0] : 5,
              y = margin + 5,
              width = this.$.canvas.width,
              height = this.$.canvas.height,
              start = (margin * 2 + 10) * (lastSelected + 1) - 10,
              end = (margin * 2 + 10) * (selected + 1) - 10,
              frameDistance = (start - end) / 17,
              dur = this.transitionDuration / 17;
        let i = 0,
            pos = start;
        ctx.clearRect(0, 0, width, height);
        const draw = () => {
          i++;
          pos -= frameDistance;
          ctx.clearRect(0, 0, width, height);
          ctx.moveTo(start, y);
          ctx.lineTo(pos, y);
          ctx.lineWidth = 10;
          ctx.strokeStyle = color;
          ctx.lineCap = 'round';
          ctx.stroke();
          if (i >= dur) {
            clearInterval(interval);
            ctx.clearRect(0, 0, width, height);
            ctx.moveTo(start, y);
            ctx.lineTo(end, y);
            ctx.lineWidth = 10;
            ctx.strokeStyle = color;
            ctx.lineCap = 'round';
            ctx.stroke();
          }
        };
        ctx.clearRect(0, 0, width, height);
        const interval = setInterval(draw, 17);
        await this._wait(this.pauseDuration + this.transitionDuration);
        pos = start;
        i = 0;
        const drawReverse = () => {
          i++;
          pos -= frameDistance;
          ctx.clearRect(0, 0, width, height);
          ctx.moveTo(end, y);
          ctx.lineTo(pos, y);
          ctx.lineWidth = 10;
          ctx.strokeStyle = color;
          ctx.lineCap = 'round';
          ctx.stroke();
          if (i >= dur) {
            clearInterval(intervalReverse);
            ctx.clearRect(0, 0, width, height);
            ctx.moveTo(end, y);
            ctx.lineTo(end, y);
            ctx.lineWidth = 10;
            ctx.strokeStyle = color;
            ctx.lineCap = 'round';
            ctx.stroke();
          }
        };
        ctx.clearRect(0, 0, width, height);
        const intervalReverse = setInterval(drawReverse, 17);
        await this._wait(this.transitionDuration);
        ctx.clearRect(0, 0, width, height);
      },
      
      _updateStyles: function() {
        this.updateStyles();
      },
      
      _wait(ms) {
        return new Promise(r => setTimeout(r, ms));
      }
    });
  </script>
</dom-module>